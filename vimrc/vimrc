" My vimrc file
"
" Maintainer:	Simon Xu<xixu@paypal.com>
" Last change:	2010 Jul 31

" general
filetype on
set number
set showcmd
set hidden
set autochdir
set incsearch
set hlsearch
set nobackup
set showmatch
set wildmenu
set ignorecase
set infercase
set notextmode
set autoread
set backspace=indent,eol,start
syntax on
map <space> <c-f>

" max width = 79
set textwidth=79
set colorcolumn=79

" formats
set fileformats=unix,dos

" folder
set foldmethod=marker

" encoding
set encoding=utf-8
set fileencodings=utf-8,chinese

" look and feel
set cursorline
set cursorcolumn
let &t_Co=256
colorscheme molokai
hi Cursorline ctermbg=darkblue guibg=darkblue
hi Cursorcolumn ctermbg=darkblue guibg=darkblue
hi Search ctermbg=red guibg=darkblue
hi Folded cterm=NONE ctermbg=blue
set laststatus=2
set statusline=%<%F%h%m%r%h%w%y\ %=\|%{&ff}\|Ln:\ %l\ Col:\ %c
if has("gui_running")
	set go=cegrLtbm
    set langmenu=zh_CN.UTF-8
    source $VIMRUNTIME/delmenu.vim
    source $VIMRUNTIME/menu.vim
endif
set mouse=a

" text format
if has("win32")
	set gfn=Consolas:h11:cANSI
else
    set gfn=Consolas\ 11
endif

" Only do this part when compiled with support for autocommands.
if has("autocmd")

  " Enable file type detection.
  " Use the default filetype settings, so that mail gets 'tw' set to 72,
  " 'cindent' is on in C files, etc.
  " Also load indent files, to automatically do language-dependent indenting.
  filetype plugin indent on

  " Put these in an autocmd group, so that we can delete them easily.
  augroup vimrcEx
  au!

  " For all text files set 'textwidth' to 78 characters.
  autocmd FileType text setlocal textwidth=78

  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  " Also don't do it when the mark is in the first line, that is the default
  " position when opening a file.
  autocmd BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \   exe "normal! g`\"" |
    \ endif

  augroup END

else

  set autoindent        " always set autoindenting on

endif " has("autocmd")


" indent
set tabstop=4
set shiftwidth=4
set smartindent
set expandtab

" spell check
set spelllang=en
set spellsuggest=5

" autocomplete
set complete=.,t,d,i
set completeopt=menu,menuone

" tabline
set showtabline=2
function! GuiTabLabel()
  let label = ''
  let bufnrlist = tabpagebuflist(v:lnum)

  " Add '+' if one of the buffers in the tab page is modified
  for bufnr in bufnrlist
    if getbufvar(bufnr, "&modified")
      let label = '+'
      break
    endif
  endfor

  " Append the number of windows in the tab page if more than one
  let wincount = tabpagewinnr(v:lnum, '$')
  if wincount > 1
    let label .= wincount
  endif
  if label != ''
    let label .= ' '
  endif

  " Append the buffer name
  return label . bufname(bufnrlist[tabpagewinnr(v:lnum) - 1])
endfunction

set guitablabel=%{GuiTabLabel()}


" ctags
let Tlist_Show_One_file = 1
let Tlist_Exit_OnlyWindow = 1
let Tlist_Use_SingleClick = 1
let Tlist_GainFocus_On_ToggleOpen = 1
let Tlist_Process_File_Always = 0
map <F9> :!ctags -R<cr>
map <F2> :TlistToggle<cr>

if has("win32")
    let g:netrw_cygwin = 0
    let g:netrw_scp_cmd = "c:\\windows\\scp.exe -i c:\\windows\\ssh.ppk"
    let g:netrw_sftp_cmd = "c:\\windows\\sftp.exe -i c:\\windows\\ssh.ppk"
endif

